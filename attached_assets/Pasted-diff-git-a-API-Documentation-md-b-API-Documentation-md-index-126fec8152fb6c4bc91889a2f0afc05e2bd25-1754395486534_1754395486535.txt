diff --git a/API_Documentation.md b/API_Documentation.md
index 126fec8152fb6c4bc91889a2f0afc05e2bd25282..8f24ec51faf7e7391cfa8863d701a02874b3d384 100644
--- a/API_Documentation.md
+++ b/API_Documentation.md
@@ -63,50 +63,55 @@ def generate_signature(data, shared_key):
     return f"sha256={signature}"
 
 # –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –¥–ª—è batch request
 payload = {"lots": [...]}  # –≤–∞—à–∏ –¥–∞–Ω–Ω—ã–µ
 signature = generate_signature(payload, "your-shared-key")
 
 # –î–ª—è polling requests
 job_id = "550e8400-e29b-41d4-a716-446655440000"
 polling_signature = generate_signature(job_id, "your-shared-key")
 ```
 
 ### –ó–∞–≥–æ–ª–æ–≤–∫–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
 
 ```http
 Content-Type: application/json
 X-Signature: sha256=your_hmac_signature_here
 User-Agent: YourApp/1.0
 ```
 
 ‚ö†Ô∏è **–í–∞–∂–Ω–æ**: –ù–µ–≤–µ—Ä–Ω—ã–µ –ø–æ–¥–ø–∏—Å–∏ –ø—Ä–∏–≤–æ–¥—è—Ç –∫ HTTP 403 Forbidden –æ—Ç–≤–µ—Ç–∞–º.
 
 ## üîÑ –°–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π —Ä–µ–∂–∏–º
 
 –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–¥–Ω–æ–≥–æ –∞–≤—Ç–æ–º–æ–±–∏–ª—è —Å –º–≥–Ω–æ–≤–µ–Ω–Ω—ã–º –ø–æ–ª—É—á–µ–Ω–∏–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ (–≤—Ä–µ–º—è –æ—Ç–≤–µ—Ç–∞ ‚â§300 —Å–µ–∫—É–Ω–¥).
 
+–°–µ—Ä–≤–∏—Å –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —è–∑—ã–∫–æ–≤ –≤ –º–∞—Å—Å–∏–≤–µ `languages`. –ë–æ–ª—å—à–æ–µ
+—á–∏—Å–ª–æ —è–∑—ã–∫–æ–≤ –º–æ–∂–µ—Ç —É–≤–µ–ª–∏—á–∏—Ç—å –≤—Ä–µ–º—è –æ–±—Ä–∞–±–æ—Ç–∫–∏. –ï—Å–ª–∏ —Å–∏—Å—Ç–µ–º–∞ –Ω–µ —É—Å–ø–µ–≤–∞–µ—Ç –ø–µ—Ä–µ–≤–µ—Å—Ç–∏ –≤—Å–µ
+—è–∑—ã–∫–∏ –≤ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –ª–∏–º–∏—Ç, –≤ –æ—Ç–≤–µ—Ç–µ –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç—Å—è –∞–Ω–≥–ª–∏–π—Å–∫–∏–µ –æ–ø–∏—Å–∞–Ω–∏—è –∏ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ
+–ø–æ–ª—è `warnings` –∏ `pending_languages`.
+
 ### –§–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–∞
 
 **POST** `/api/v1/generate-descriptions`
 
 ```json
 {
   "signature": "sha256=hmac_sha256_signature_here",
   "version": "1.0.0",
   "languages": ["en", "ru", "de"],
   "lots": [
     {
       "lot_id": "sync-12345",
       "additional_info": "2021 BMW X5, front collision damage, airbags deployed",
       "images": [
         {"url": "https://example.com/bmw-front.jpg"},
         {"url": "https://example.com/bmw-side.jpg"},
         {"url": "https://example.com/bmw-interior.jpg"}
       ]
     }
   ]
 }
 ```
 
 ### –£—Å–ø–µ—à–Ω—ã–π –æ—Ç–≤–µ—Ç (200 OK)
 
@@ -115,51 +120,53 @@ User-Agent: YourApp/1.0
   "version": "1.0.0",
   "processing_mode": "synchronous",
   "total_lots": 1,
   "processed_at": "2025-08-05T08:30:15Z",
   "lots": [
     {
       "lot_id": "sync-12345",
       "status": "completed",
       "processed_images": 3,
       "descriptions": [
         {
           "language": "en",
           "damages": "<p>Significant front-end collision damage with extensive structural deformation. The vehicle shows impact damage to the front bumper, hood, and headlight assemblies. Airbag deployment indicates high-impact collision. Engine compartment integrity may be compromised.</p>"
         },
         {
           "language": "ru",
           "damages": "<p>–ó–Ω–∞—á–∏—Ç–µ–ª—å–Ω—ã–µ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω–∏—è –ø–µ—Ä–µ–¥–Ω–µ–π —á–∞—Å—Ç–∏ –æ—Ç —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è —Å –æ–±—à–∏—Ä–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä–Ω–æ–π –¥–µ—Ñ–æ—Ä–º–∞—Ü–∏–µ–π. –ê–≤—Ç–æ–º–æ–±–∏–ª—å –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –ø–æ–≤—Ä–µ–∂–¥–µ–Ω–∏—è –ø–µ—Ä–µ–¥–Ω–µ–≥–æ –±–∞–º–ø–µ—Ä–∞, –∫–∞–ø–æ—Ç–∞ –∏ –±–ª–æ–∫–æ–≤ —Ñ–∞—Ä. –°—Ä–∞–±–∞—Ç—ã–≤–∞–Ω–∏–µ –ø–æ–¥—É—à–µ–∫ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ —Å–∏–ª—å–Ω–æ–µ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ.</p>"
         },
         {
           "language": "de",
           "damages": "<p>Erhebliche Frontsch√§den durch Kollision mit ausgedehnter struktureller Verformung. Das Fahrzeug zeigt Aufprallsch√§den an der vorderen Sto√üstange, der Motorhaube und den Scheinwerfereinheiten.</p>"
         }
       ],
       "missing_images": []
     }
-  ]
+  ],
+  "pending_languages": [],
+  "warnings": []
 }
 ```
 
 ## üì¶ –ü–∞–∫–µ—Ç–Ω—ã–π —Ä–µ–∂–∏–º
 
 –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –∞–≤—Ç–æ–º–æ–±–∏–ª–µ–π (2-50,000) —Å PostgreSQL persistence –∏ webhook —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è–º–∏.
 
 ### –°–æ–∑–¥–∞–Ω–∏–µ –ø–∞–∫–µ—Ç–Ω–æ–≥–æ –∑–∞–¥–∞–Ω–∏—è
 
 **POST** `/api/v1/generate-descriptions`
 
 ```json
 {
   "signature": "sha256=hmac_sha256_signature_here",
   "version": "1.0.0",
   "languages": ["en", "fr", "de"],
   "lots": [
     {
       "lot_id": "batch-001",
       "webhook": "https://your-app.com/webhooks/generation-complete",
       "additional_info": "2019 Mercedes C-Class, minor rear damage",
       "images": [
         {"url": "https://example.com/merc-rear.jpg"},
         {"url": "https://example.com/merc-bumper.jpg"}
       ]
diff --git a/config.py b/config.py
index 91a214d2aa9b6c7726ad83447110beb1283659e0..00bd4a696c8f8b505bd93242e6b982460f4c39cf 100644
--- a/config.py
+++ b/config.py
@@ -4,41 +4,46 @@ import os
 OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "")
 
 # HMAC Security
 SHARED_KEY = os.getenv("SHARED_KEY", "default-shared-key-change-in-production")
 
 # Vision System Prompt
 VISION_SYSTEM_PROMPT = os.getenv(
     "VISION_SYSTEM_PROMPT", 
     """You are an expert automotive damage assessor. Analyze the provided car images and generate a detailed description of any visible damage, condition issues, or notable features. Focus on:
 - Exterior damage (dents, scratches, rust, paint issues)
 - Interior condition (wear, tears, stains)
 - Mechanical visible issues
 - Overall condition assessment
 - Market-relevant details for potential buyers
 
 Provide your response in clear, professional language suitable for a vehicle listing. Be specific about locations and severity of any damage found."""
 )
 
 # Processing Limits
 MAX_LINE_BYTES = 1_048_576  # 1 MB
 MAX_FILE_BYTES = 200_000_000  # 200 MB
 MAX_LINES = 50_000
 MAX_SYNC_IMAGES = 20
 MAX_IMAGE_SIZE = 10_000_000  # 10 MB
 
+# Translation configuration
+SYNC_TRANSLATION_WARNING_THRESHOLD = int(
+    os.getenv("SYNC_TRANSLATION_WARNING_THRESHOLD", "5")
+)
+
 # Batch API Limits
 ACTIVE_BATCH_LIMIT_KEY = int(os.getenv("ACTIVE_BATCH_LIMIT_KEY", "2"))
 ACTIVE_BATCH_LIMIT_GLB = int(os.getenv("ACTIVE_BATCH_LIMIT_GLB", "10"))
 
 # Retry Configuration
 RETRY_ATTEMPTS = int(os.getenv("RETRY_ATTEMPTS", "5"))
 BASE_DELAY_SEC = int(os.getenv("BASE_DELAY_SEC", "2"))
 
 # Image Validation Timeouts
 IMAGE_HEAD_TIMEOUT = int(os.getenv("IMAGE_HEAD_TIMEOUT", "3"))
 IMAGE_GET_TIMEOUT = int(os.getenv("IMAGE_GET_TIMEOUT", "5"))
 IMAGE_GET_MAX_SIZE = int(os.getenv("IMAGE_GET_MAX_SIZE", "32768"))  # 32 KB for fallback GET
 
 # Webhook Configuration
 WEBHOOK_RETRY_ATTEMPTS = int(os.getenv("WEBHOOK_RETRY_ATTEMPTS", "5"))
 WEBHOOK_BASE_DELAY = int(os.getenv("WEBHOOK_BASE_DELAY", "1"))
diff --git a/routes/api.py b/routes/api.py
index a708a96850f789f00bb7810dc4c148deea1c876e..59e1940a5a51ed6e7285026c2152bd1d95f6b8fb 100644
--- a/routes/api.py
+++ b/routes/api.py
@@ -1,34 +1,34 @@
 import json
 import logging
 import time
 from flask import Blueprint, request, jsonify
 from services.openai_client import OpenAIClient
 from services.image_validator import ImageValidator
 from services.signature_validator import SignatureValidator
 from services.batch_processor import BatchProcessor
-from config import MAX_SYNC_IMAGES
+from config import MAX_SYNC_IMAGES, SYNC_TRANSLATION_WARNING_THRESHOLD
 
 logger = logging.getLogger(__name__)
 
 api_bp = Blueprint('api', __name__, url_prefix='/api/v1')
 
 # Initialize services
 openai_client = OpenAIClient()
 image_validator = ImageValidator()
 signature_validator = SignatureValidator()
 batch_processor = BatchProcessor()
 
 @api_bp.route('/generate-descriptions', methods=['POST'])
 def generate_descriptions():
     """
     Main endpoint for generating car descriptions
     """
     try:
         # Parse JSON request
         if not request.is_json:
             return jsonify({"error": "Content-Type must be application/json"}), 400
         
         data = request.get_json()
         
         # Validate required fields
         required_fields = ['signature', 'version', 'languages', 'lots']
@@ -90,107 +90,113 @@ def handle_sync_request(lot, languages):
         image_urls = [img['url'] for img in images if 'url' in img]
         
         # Check sync limits
         if len(image_urls) > MAX_SYNC_IMAGES:
             return jsonify({"error": f"Too many images for sync mode: {len(image_urls)} > {MAX_SYNC_IMAGES}"}), 400
         
         # Validate images
         valid_urls, unreachable_urls = image_validator.validate_images(image_urls)
         
         # Check image threshold
         if not image_validator.check_image_threshold(len(image_urls), len(valid_urls)):
             return jsonify({
                 "error": "image_unreachable",
                 "message": "Too many unreachable images",
                 "missing_images": unreachable_urls
             }), 400
         
         # Generate vision description
         english_description = openai_client.generate_vision_description(valid_urls, additional_info)
         
         # Prepare descriptions
         descriptions = [
             {"language": "en", "damages": f"<p>{english_description}</p>"}
         ]
         
-        # Optimize translations to prevent worker timeout
-        # Limit number of languages in sync mode to prevent timeout
+        # Prepare translations
         non_english_languages = [lang for lang in languages if lang.lower() != 'en']
-        
-        # In sync mode, limit to maximum 2 additional languages to prevent timeout
-        max_sync_translations = 2
-        if len(non_english_languages) > max_sync_translations:
-            logger.warning(f"Too many languages for sync mode ({len(non_english_languages)}), limiting to {max_sync_translations}")
-            non_english_languages = non_english_languages[:max_sync_translations]
-        
+        warnings = []
+        if len(non_english_languages) > SYNC_TRANSLATION_WARNING_THRESHOLD:
+            warnings.append(
+                f"processing {len(non_english_languages)} languages may increase response time"
+            )
+
         # Generate translations with timeout protection
         translation_start = time.time()
         max_translation_time = 45  # Maximum 45 seconds for all translations
-        
-        for lang in non_english_languages:
+        pending_languages = []
+
+        for idx, lang in enumerate(non_english_languages):
             # Check if we're running out of time
             elapsed = time.time() - translation_start
             if elapsed > max_translation_time:
-                logger.warning(f"Translation timeout reached, skipping remaining languages")
-                # Add English fallback for remaining languages
-                for remaining_lang in [l for l in non_english_languages if l not in [desc['language'] for desc in descriptions]]:
+                logger.warning(
+                    "Translation timeout reached, using English fallback for remaining languages"
+                )
+                pending_languages = non_english_languages[idx:]
+                for remaining_lang in pending_languages:
                     descriptions.append({
                         "language": remaining_lang,
                         "damages": f"<p>{english_description}</p>"
                     })
+                warnings.append("translation_time_limit_exceeded")
                 break
-            
+
             try:
-                # Set shorter timeout for individual translation
                 translated_text = openai_client.translate_text(english_description, lang)
                 descriptions.append({
                     "language": lang,
                     "damages": f"<p>{translated_text}</p>"
                 })
             except Exception as e:
                 logger.error(f"Translation failed for {lang}: {str(e)}")
-                # Use English as fallback
                 descriptions.append({
                     "language": lang,
                     "damages": f"<p>{english_description}</p>"
                 })
         
         # Prepare response
         response = {
             "version": "1.0.0",
             "lots": [
                 {
                     "lot_id": lot_id,
                     "descriptions": descriptions
                 }
             ]
         }
         
         # Add missing images if any
         if unreachable_urls:
             response["lots"][0]["missing_images"] = unreachable_urls
-        
+
+        # Add warnings or pending languages if any
+        if warnings:
+            response["warnings"] = warnings
+        if pending_languages:
+            response["pending_languages"] = pending_languages
+
         return jsonify(response), 200
     
     except Exception as e:
         logger.error(f"Sync processing error: {str(e)}")
         return jsonify({"error": "Processing failed", "details": str(e)}), 500
 
 def handle_batch_request(lots, languages):
     """
     Handle batch processing for multiple lots with timeout protection
     """
     try:
         # Add timeout protection for batch creation
         start_time = time.time()
         max_creation_time = 20  # Maximum 20 seconds for batch creation
         
         logger.info(f"Starting batch creation for {len(lots)} lots")
         
         # Create batch job with optimized processing
         job_id = batch_processor.create_batch_job(lots, languages)
         
         creation_time = time.time() - start_time
         logger.info(f"Batch job {job_id} created in {creation_time:.2f}s")
         
         return jsonify({
             "job_id": job_id,
